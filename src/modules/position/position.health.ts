import {inject, injectable} from "inversify";
import { Subscription } from "rxjs";
import * as moment from "moment";
import { SYMBOLS } from "../../ioc";
import { IPrediction } from "../epoch-builder";
import { IPredictionService } from "../prediction";
import { IMarketState, IMarketStateService, ITAIntervalID } from "../market-state";
import { IBinancePositionSide } from "../binance";
import { IUtilitiesService } from "../utilities";
import { 
    IPositionHealth,
    IPositionModel,
    IPositionSideHealth,
    IPositionHealthState,
    IPositionHealthWeights,
    IActivePosition,
    IPositionHealthCandlestickRecord,
    IPositionHealthActiveCandlestick,
    IPositionValidations
} from "./interfaces";




@injectable()
export class PositionHealth implements IPositionHealth {
    // Inject dependencies
    @inject(SYMBOLS.PredictionService)          private _prediction: IPredictionService;
    @inject(SYMBOLS.MarketStateService)         private _marketState: IMarketStateService;
    @inject(SYMBOLS.PositionModel)              private _model: IPositionModel;
    @inject(SYMBOLS.PositionValidations)        private _validations: IPositionValidations;
    @inject(SYMBOLS.UtilitiesService)           private _utils: IUtilitiesService;


    /**
     * Position Health Weights
     * The weights used by each module in order to calculate the 
     * position's health points.
     */
    public weights: IPositionHealthWeights;


    /**
     * Long Position Health
     * The active long position's health, if none is, this value is undefined.
     */
    public long: IPositionSideHealth|null = null;



    /**
     * Short Position Health
     * The active short position's health, if none is, this value is undefined.
     */
    public short: IPositionSideHealth|null = null;


    /**
     * Prediction Stream
     * Real time connection to the predictions generated by the PredictionModel.
     */
    private pred: IPrediction|undefined;
    private predSub: Subscription;


    /**
     * Market State Stream
     * Real time connection to the current market state.
     */
    private ms: IMarketState;
    private msSub: Subscription;


    /**
     * Position Health Active Candlesticks
     * The candlesticks are initially built in RAM and only stored in disk
     * once the candlestick ends.
     * When retrieving candlesticks, the active one is appended to the 
     * list stored in the disk.
     */
    private longCandlestick: IPositionHealthActiveCandlestick = {
        ot: undefined,
        hp: undefined,
        dd: undefined,
        mgdd: undefined
    }
    private shortCandlestick: IPositionHealthActiveCandlestick = {
        ot: undefined,
        hp: undefined,
        dd: undefined,
        mgdd: undefined
    }
    private readonly candlestickIntervalMinutes: number = 30;




    constructor() {}










    /***************
     * Initializer * 
     ***************/





    /**
     * Initializes the Position Health Module.
     * @returns Promise<void>
     */
    public async initialize(): Promise<void> {
        // Subscribe the to prediction stream
        this.predSub = this._prediction.active.subscribe((pred: IPrediction|undefined) => {
            this.pred = pred;
        });

        // Subscribe to the market state stream
        this.msSub = this._marketState.active.subscribe((ms: IMarketState) => {
            this.ms = ms;
        });

        // Initialize the health weights
        await this.initializeWeights();

        // Initialize the stored health
        const health: IPositionHealthState|undefined = await this._model.getHealth();
        if (health) {
            this.long = health.long;
            this.short = health.short;
        } else {
            await this._model.createHealth({long: this.long, short: this.short});
        }
    }




    /**
     * Stops the subscriptions too all the external modules.
     */
    public stop(): void {
        if (this.predSub) this.predSub.unsubscribe();
        if (this.msSub) this.msSub.unsubscribe();
    }


    
















    /******************************
     * Position Health Calculator *
     ******************************/









    /**
     * Calculates the health for all active positions.
     * @param long 
     * @param short 
     * @param spotPrice 
     * @param minGain 
     * @returns Promise<void>
     */
    public async refreshHealth(
        long: IActivePosition|undefined,
        short: IActivePosition|undefined,
        spotPrice: number,
        minGain: number
    ): Promise<void> {
        // Make sure the prediction and the market state are properly set
        if (!this.pred) {
            console.log(this.pred);
            throw new Error(this._utils.buildApiError(`The position health could not be calculated because the 
            prediction model is not currently active.`, 32000));
        }
        if (!this.ms) {
            console.log(this.ms);
            throw new Error(this._utils.buildApiError(`The position health could not be calculated because the 
            market state is not currently active.`, 32001));
        }

        /**
         * Evaluate the Long Position's Health. If there isn't an active one 
         * but there was in the previous check, clean the candlesticks.
         */
        if (long) {
            this.long = this.calculateHealth("LONG", long.entry_price, spotPrice, minGain);
        } else { 
            if (this.long) await this.cleanCandlesticks("LONG");
            this.long = null;
        }

        /**
         * Evaluate the Short Position's Health. If there isn't an active one 
         * but there was in the previous check, clean the candlesticks.
         */
        if (short) {
            this.short = this.calculateHealth("SHORT", short.entry_price, spotPrice, minGain);
        } else { 
            if (this.short) await this.cleanCandlesticks("SHORT");
            this.short = null;
        }

        // Update the state on the db
        await this._model.updateHealth({long: this.long, short: this.short});

        // Finally, process the candlesticks if a side is active
        if (this.long || this.short) await this.processCandlesticks();
    }







    /**
     * Creates or updates the health for a position side.
     * @param side 
     * @param entryPrice
     * @param spotPrice
     * @param minGain
     * @returns IPositionSideHealth
     */
    private calculateHealth(side: IBinancePositionSide, entryPrice: number, spotPrice: number, minGain: number): IPositionSideHealth {
        // Firstly, initialize the side's health in case it hasn't been
        let health: IPositionSideHealth|null = side == "LONG" ? this.long: this.short;
        if (!health) {
            health = {
                os: this.pred.s,
                ooi: this.ms.open_interest.interest.at(-1),
                olsr: this.ms.long_short_ratio.ratio.at(-1),
                ohp: 0,
                hhp: 0,
                lhp: 0,
                chp: 0,
                dd: 0,
                mg: 0,
                mgdd: 0,
                ts: Date.now()
            }
        }

        // Init the health points
        let hp: number = 0;

        // Evaluate the trend sum
        hp += this.evaluateTrendSum(side, health.os);

        // Evaluate the trend state
        hp += this.evaluateTrendState(side);

        // Evaluate the TA
        hp += this.evaluateTechnicalAnalysis(side, "15m"); 
        hp += this.evaluateTechnicalAnalysis(side, "30m"); 
        hp += this.evaluateTechnicalAnalysis(side, "1h"); 
        hp += this.evaluateTechnicalAnalysis(side, "2h"); 
        hp += this.evaluateTechnicalAnalysis(side, "4h"); 
        hp += this.evaluateTechnicalAnalysis(side, "1d");

        // Evaluate the open interest
        hp += this.evaluateOpenInterest(side, health.ooi);

        // Evaluate the open interest state
        hp += this.evaluateOpenInterestState(side);

        // Evaluate the long/short ratio
        hp += this.evaluateLongShortRatio(side, health.olsr);

        // Evaluate the long/short ratio state
        hp += this.evaluateLongShortRatioState(side);

        // Evaluate the volume direction
        hp += this.evaluateVolumeDirection(side);

        // Format the HP correctly
        hp = <number>this._utils.outputNumber(hp);

        // Complete the health object if it was partially initialized
        if (health.ohp == 0) {
            health.ohp = hp;
            health.hhp = hp;
            health.lhp = hp;
            health.chp = hp;
        }

        // Otherwise, update the health point related properties
        else {
            health.hhp = hp > health.hhp ? hp: health.hhp;
            health.lhp = hp < health.lhp ? hp: health.lhp;
            health.chp = hp;
        }

        /**
         * For there to be a hp drawdown, the current health must be less than the highest.
         * Otherwise, the drawdown is equals to 0.
         */
        if (health.hhp > health.chp) {
            health.dd = <number>this._utils.calculatePercentageChange(health.hhp, health.chp);
        } else { health.dd = 0 }

        // Calculate the max gain & current drawdown%
        const { max_gain, max_gain_drawdown } = this.calculateGain(side, health.mg, entryPrice, spotPrice, minGain);
        health.mg = max_gain;
        health.mgdd = max_gain_drawdown;

        // Finally, return the current health
        return health;
    }




    /**
     * Calculates the max gain and the max gain drawdown% for a position side.
     * If the position is not profitable, both values are 0.
     * @param side 
     * @param currentMaxGain 
     * @param entryPrice 
     * @param spotPrice 
     * @param minGain 
     * @returns {max_gain: number, max_gain_drawdown: number}
     */
    private calculateGain(
        side: IBinancePositionSide,
        currentMaxGain: number,
        entryPrice: number,
        spotPrice: number,
        minGain: number
    ): {max_gain: number, max_gain_drawdown: number} {
        // Init values
        let maxGain: number = 0;
        let maxGainDrawdown: number = 0;

        // Calculate the gain values for a long position (if profitable)
        if (side == "LONG" && spotPrice > entryPrice) {
            // Calculate the current gain
            const currentGain: number = <number>this._utils.calculatePercentageChange(entryPrice, spotPrice);

            // Ensure the gain is greater than or equals to the requirement
            if (currentGain >= minGain) {
                // If the max gain is equals or greater than the current, there is no drawdown
                if (currentGain >= currentMaxGain) { maxGain = currentGain }

                // Otherwise, calculate the drawdown%
                else {
                    maxGain = currentMaxGain;
                    maxGainDrawdown = <number>this._utils.calculatePercentageChange(maxGain, currentGain);
                }
            }
        }

        // Calculate the gain values for a short position (if profitable)
        else if (side == "SHORT" && spotPrice < entryPrice) {
            // Calculate the current absolute gain
            const currentGain: number = Math.abs(<number>this._utils.calculatePercentageChange(entryPrice, spotPrice));

            // Ensure the gain is greater than or equals to the requirement
            if (currentGain >= minGain) {
                // If the max gain is equals or greater than the current, there is no drawdown
                if (currentGain >= currentMaxGain) { maxGain = currentGain }

                // Otherwise, calculate the drawdown%
                else {
                    maxGain = currentMaxGain;
                    maxGainDrawdown = <number>this._utils.calculatePercentageChange(maxGain, currentGain);
                }
            }
        }

        // Finally, return the gain details
        return { max_gain: maxGain, max_gain_drawdown: maxGainDrawdown }
    }









    /* Health Point Evaluations */



    /**
     * Calculates the prediction HP based on the initial and the current
     * sum.
     * @param side 
     * @param openSum 
     * @returns number
     */
    private evaluateTrendSum(side: IBinancePositionSide, openSum: number): number {
        // Init the score
        let score: number = 0.5;

        // Evaluate a trend sum that is increasing
        if (this.pred.s > openSum) {
            const alterMultiplier: number = openSum > 0 ? 1: -1;
            if        (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 95*alterMultiplier)) {
                score = side == "LONG" ? 1: 0;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 93*alterMultiplier)) {
                score = side == "LONG" ? 0.98: 0.02;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 91*alterMultiplier)) {
                score = side == "LONG" ? 0.96: 0.04;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 89*alterMultiplier)) {
                score = side == "LONG" ? 0.95: 0.05;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 87*alterMultiplier)) {
                score = side == "LONG" ? 0.94: 0.06;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 85*alterMultiplier)) {
                score = side == "LONG" ? 0.93: 0.07;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 83*alterMultiplier)) {
                score = side == "LONG" ? 0.92: 0.08;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 81*alterMultiplier)) {
                score = side == "LONG" ? 0.91: 0.09;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 79*alterMultiplier)) {
                score = side == "LONG" ? 0.90: 0.10;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 77*alterMultiplier)) {
                score = side == "LONG" ? 0.89: 0.11;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 75*alterMultiplier)) {
                score = side == "LONG" ? 0.88: 0.12;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 73*alterMultiplier)) {
                score = side == "LONG" ? 0.87: 0.13;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 71*alterMultiplier)) {
                score = side == "LONG" ? 0.86: 0.14;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 69*alterMultiplier)) {
                score = side == "LONG" ? 0.85: 0.15;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 67*alterMultiplier)) {
                score = side == "LONG" ? 0.84: 0.16;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 65*alterMultiplier)) {
                score = side == "LONG" ? 0.83: 0.17;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 63*alterMultiplier)) {
                score = side == "LONG" ? 0.82: 0.18;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 61*alterMultiplier)) {
                score = side == "LONG" ? 0.81: 0.19;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 59*alterMultiplier)) {
                score = side == "LONG" ? 0.80: 0.20;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 57*alterMultiplier)) {
                score = side == "LONG" ? 0.79: 0.21;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 55*alterMultiplier)) {
                score = side == "LONG" ? 0.78: 0.22;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 53*alterMultiplier)) {
                score = side == "LONG" ? 0.77: 0.23;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 51*alterMultiplier)) {
                score = side == "LONG" ? 0.76: 0.24;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 49*alterMultiplier)) {
                score = side == "LONG" ? 0.75: 0.25;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 47*alterMultiplier)) {
                score = side == "LONG" ? 0.74: 0.26;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 45*alterMultiplier)) {
                score = side == "LONG" ? 0.73: 0.27;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 43*alterMultiplier)) {
                score = side == "LONG" ? 0.72: 0.28;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 41*alterMultiplier)) {
                score = side == "LONG" ? 0.71: 0.29;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 39*alterMultiplier)) {
                score = side == "LONG" ? 0.70: 0.30;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 37*alterMultiplier)) {
                score = side == "LONG" ? 0.69: 0.31;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 35*alterMultiplier)) {
                score = side == "LONG" ? 0.68: 0.32;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 33*alterMultiplier)) {
                score = side == "LONG" ? 0.67: 0.33;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 31*alterMultiplier)) {
                score = side == "LONG" ? 0.66: 0.34;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 29*alterMultiplier)) {
                score = side == "LONG" ? 0.65: 0.35;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 27*alterMultiplier)) {
                score = side == "LONG" ? 0.64: 0.36;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 25*alterMultiplier)) {
                score = side == "LONG" ? 0.63: 0.37;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 23*alterMultiplier)) {
                score = side == "LONG" ? 0.62: 0.38;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 21*alterMultiplier)) {
                score = side == "LONG" ? 0.61: 0.39;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 19*alterMultiplier)) {
                score = side == "LONG" ? 0.60: 0.40;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 17*alterMultiplier)) {
                score = side == "LONG" ? 0.59: 0.41;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 15*alterMultiplier)) {
                score = side == "LONG" ? 0.58: 0.42;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 13*alterMultiplier)) {
                score = side == "LONG" ? 0.57: 0.43;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 11*alterMultiplier)) {
                score = side == "LONG" ? 0.56: 0.44;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 9*alterMultiplier)) {
                score = side == "LONG" ? 0.55: 0.45;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 7*alterMultiplier)) {
                score = side == "LONG" ? 0.54: 0.46;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 5*alterMultiplier)) {
                score = side == "LONG" ? 0.53: 0.47;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 3*alterMultiplier)) {
                score = side == "LONG" ? 0.52: 0.48;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 1*alterMultiplier)) {
                score = side == "LONG" ? 0.51: 0.49;
            }
        }

        // Evaluate a trend sum that is decreasing
        else if (this.pred.s < openSum) {
            const alterMultiplier: number = openSum < 0 ? 1: -1;
            if        (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 95*alterMultiplier)) {
                score = side == "SHORT" ? 1: 0;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 93*alterMultiplier)) {
                score = side == "SHORT" ? 0.98: 0.02;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 91*alterMultiplier)) {
                score = side == "SHORT" ? 0.96: 0.04;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 89*alterMultiplier)) {
                score = side == "SHORT" ? 0.95: 0.05;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 87*alterMultiplier)) {
                score = side == "SHORT" ? 0.94: 0.06;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 85*alterMultiplier)) {
                score = side == "SHORT" ? 0.93: 0.07;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 83*alterMultiplier)) {
                score = side == "SHORT" ? 0.92: 0.08;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 81*alterMultiplier)) {
                score = side == "SHORT" ? 0.91: 0.09;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 79*alterMultiplier)) {
                score = side == "SHORT" ? 0.90: 0.10;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 77*alterMultiplier)) {
                score = side == "SHORT" ? 0.89: 0.11;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 75*alterMultiplier)) {
                score = side == "SHORT" ? 0.88: 0.12;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 73*alterMultiplier)) {
                score = side == "SHORT" ? 0.87: 0.13;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 71*alterMultiplier)) {
                score = side == "SHORT" ? 0.86: 0.14;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 69*alterMultiplier)) {
                score = side == "SHORT" ? 0.85: 0.15;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 67*alterMultiplier)) {
                score = side == "SHORT" ? 0.84: 0.16;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 65*alterMultiplier)) {
                score = side == "SHORT" ? 0.83: 0.17;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 63*alterMultiplier)) {
                score = side == "SHORT" ? 0.82: 0.18;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 61*alterMultiplier)) {
                score = side == "SHORT" ? 0.81: 0.19;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 59*alterMultiplier)) {
                score = side == "SHORT" ? 0.80: 0.20;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 57*alterMultiplier)) {
                score = side == "SHORT" ? 0.79: 0.21;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 55*alterMultiplier)) {
                score = side == "SHORT" ? 0.78: 0.22;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 53*alterMultiplier)) {
                score = side == "SHORT" ? 0.77: 0.23;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 51*alterMultiplier)) {
                score = side == "SHORT" ? 0.76: 0.24;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 49*alterMultiplier)) {
                score = side == "SHORT" ? 0.75: 0.25;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 47*alterMultiplier)) {
                score = side == "SHORT" ? 0.74: 0.26;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 45*alterMultiplier)) {
                score = side == "SHORT" ? 0.73: 0.27;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 43*alterMultiplier)) {
                score = side == "SHORT" ? 0.72: 0.28;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 41*alterMultiplier)) {
                score = side == "SHORT" ? 0.71: 0.29;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 39*alterMultiplier)) {
                score = side == "SHORT" ? 0.70: 0.30;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 37*alterMultiplier)) {
                score = side == "SHORT" ? 0.69: 0.31;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 35*alterMultiplier)) {
                score = side == "SHORT" ? 0.68: 0.32;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 33*alterMultiplier)) {
                score = side == "SHORT" ? 0.67: 0.33;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 31*alterMultiplier)) {
                score = side == "SHORT" ? 0.66: 0.34;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 29*alterMultiplier)) {
                score = side == "SHORT" ? 0.65: 0.35;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 27*alterMultiplier)) {
                score = side == "SHORT" ? 0.64: 0.36;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 25*alterMultiplier)) {
                score = side == "SHORT" ? 0.63: 0.37;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 23*alterMultiplier)) {
                score = side == "SHORT" ? 0.62: 0.38;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 21*alterMultiplier)) {
                score = side == "SHORT" ? 0.61: 0.39;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 19*alterMultiplier)) {
                score = side == "SHORT" ? 0.60: 0.40;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 17*alterMultiplier)) {
                score = side == "SHORT" ? 0.59: 0.41;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 15*alterMultiplier)) {
                score = side == "SHORT" ? 0.58: 0.42;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 13*alterMultiplier)) {
                score = side == "SHORT" ? 0.57: 0.43;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 11*alterMultiplier)) {
                score = side == "SHORT" ? 0.56: 0.44;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 9*alterMultiplier)) {
                score = side == "SHORT" ? 0.55: 0.45;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 7*alterMultiplier)) {
                score = side == "SHORT" ? 0.54: 0.46;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 5*alterMultiplier)) {
                score = side == "SHORT" ? 0.53: 0.47;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 3*alterMultiplier)) {
                score = side == "SHORT" ? 0.52: 0.48;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 1*alterMultiplier)) {
                score = side == "SHORT" ? 0.51: 0.49;
            }
        }

        // Finally, return the score
        return this.weights.trend_sum * score;
    }





    /**
     * Calculates the prediction state HP based on the current state and side.
     * @param side 
     * @returns number
     */
    private evaluateTrendState(side: IBinancePositionSide): number {
        // Init the score
        let score: number = 0.5;

        // Evaluate an increasing trend state with low intensity
        if (this._prediction.activeState >= 9 && this._prediction.activeStateIntesity == 1) {
            score = side == "LONG" ? 0.68: 0.32;
        } else if (this._prediction.activeState == 8 && this._prediction.activeStateIntesity == 1) {
            score = side == "LONG" ? 0.66: 0.34;
        } else if (this._prediction.activeState == 7 && this._prediction.activeStateIntesity == 1) {
            score = side == "LONG" ? 0.64: 0.36;
        } else if (this._prediction.activeState == 6 && this._prediction.activeStateIntesity == 1) {
            score = side == "LONG" ? 0.62: 0.38;
        } else if (this._prediction.activeState == 5 && this._prediction.activeStateIntesity == 1) {
            score = side == "LONG" ? 0.60: 0.40;
        } else if (this._prediction.activeState == 4 && this._prediction.activeStateIntesity == 1) {
            score = side == "LONG" ? 0.58: 0.42;
        } else if (this._prediction.activeState == 3 && this._prediction.activeStateIntesity == 1) {
            score = side == "LONG" ? 0.56: 0.44;
        } else if (this._prediction.activeState == 2 && this._prediction.activeStateIntesity == 1) {
            score = side == "LONG" ? 0.54: 0.46;
        } else if (this._prediction.activeState == 1 && this._prediction.activeStateIntesity == 1) {
            score = side == "LONG" ? 0.52: 0.48;
        }

        // Evaluate an increasing trend state with high intensity
        else if (this._prediction.activeState >= 9 && this._prediction.activeStateIntesity == 2) {
            score = side == "LONG" ? 1: 0;
        } else if (this._prediction.activeState == 8 && this._prediction.activeStateIntesity == 2) {
            score = side == "LONG" ? 0.95: 0.05;
        } else if (this._prediction.activeState == 7 && this._prediction.activeStateIntesity == 2) {
            score = side == "LONG" ? 0.90: 0.10;
        } else if (this._prediction.activeState == 6 && this._prediction.activeStateIntesity == 2) {
            score = side == "LONG" ? 0.85: 0.15;
        } else if (this._prediction.activeState == 5 && this._prediction.activeStateIntesity == 2) {
            score = side == "LONG" ? 0.80: 0.20;
        } else if (this._prediction.activeState == 4 && this._prediction.activeStateIntesity == 2) {
            score = side == "LONG" ? 0.75: 0.25;
        } else if (this._prediction.activeState == 3 && this._prediction.activeStateIntesity == 2) {
            score = side == "LONG" ? 0.70: 0.30;
        } else if (this._prediction.activeState == 2 && this._prediction.activeStateIntesity == 2) {
            score = side == "LONG" ? 0.65: 0.35;
        } else if (this._prediction.activeState == 1 && this._prediction.activeStateIntesity == 2) {
            score = side == "LONG" ? 0.55: 0.45;
        }

        // Evaluate a decreasing trend state with low intensity
        else if (this._prediction.activeState == -1 && this._prediction.activeStateIntesity == -1) {
            score = side == "SHORT" ? 0.52: 0.48;
        } else if (this._prediction.activeState == -2 && this._prediction.activeStateIntesity == -1) {
            score = side == "SHORT" ? 0.54: 0.46;
        } else if (this._prediction.activeState == -3 && this._prediction.activeStateIntesity == -1) {
            score = side == "SHORT" ? 0.56: 0.44;
        } else if (this._prediction.activeState == -4 && this._prediction.activeStateIntesity == -1) {
            score = side == "SHORT" ? 0.58: 0.42;
        } else if (this._prediction.activeState == -5 && this._prediction.activeStateIntesity == -1) {
            score = side == "SHORT" ? 0.60: 0.40;
        } else if (this._prediction.activeState == -6 && this._prediction.activeStateIntesity == -1) {
            score = side == "SHORT" ? 0.62: 0.38;
        } else if (this._prediction.activeState == -7 && this._prediction.activeStateIntesity == -1) {
            score = side == "SHORT" ? 0.64: 0.36;
        } else if (this._prediction.activeState == -8 && this._prediction.activeStateIntesity == -1) {
            score = side == "SHORT" ? 0.66: 0.34;
        } else if (this._prediction.activeState <= -9 && this._prediction.activeStateIntesity == -1) {
            score = side == "SHORT" ? 0.68: 0.32;
        }

        // Evaluate a decreasing trend state with high intensity
        else if (this._prediction.activeState == -1 && this._prediction.activeStateIntesity == -2) {
            score = side == "SHORT" ? 0.55: 0.45;
        } else if (this._prediction.activeState == -2 && this._prediction.activeStateIntesity == -2) {
            score = side == "SHORT" ? 0.65: 0.35;
        } else if (this._prediction.activeState == -3 && this._prediction.activeStateIntesity == -2) {
            score = side == "SHORT" ? 0.70: 0.30;
        } else if (this._prediction.activeState == -4 && this._prediction.activeStateIntesity == -2) {
            score = side == "SHORT" ? 0.75: 0.25;
        } else if (this._prediction.activeState == -5 && this._prediction.activeStateIntesity == -2) {
            score = side == "SHORT" ? 0.80: 0.20;
        } else if (this._prediction.activeState == -6 && this._prediction.activeStateIntesity == -2) {
            score = side == "SHORT" ? 0.85: 0.15;
        } else if (this._prediction.activeState == -7 && this._prediction.activeStateIntesity == -2) {
            score = side == "SHORT" ? 0.90: 0.10;
        } else if (this._prediction.activeState == -8 && this._prediction.activeStateIntesity == -2) {
            score = side == "SHORT" ? 0.95: 0.05;
        } else if (this._prediction.activeState <= -9 && this._prediction.activeStateIntesity == -2) {
            score = side == "SHORT" ? 1: 0;
        }

        // Finally, return the score
        return this.weights.trend_state * score;
    }





    /**
     * Calculates the technical analysis HP based on the current state.
     * @param side 
     * @param taInterval 
     * @returns number
     */
    private evaluateTechnicalAnalysis(side: IBinancePositionSide, taInterval: ITAIntervalID): number {
        // Init the score
        let score: number = 0.5;

        // Evaluate the current state score based on the side
        if      (this.ms.technical_analysis[taInterval].s.a == -2) { score = side == "SHORT" ? 1: 0 } 
        else if (this.ms.technical_analysis[taInterval].s.a == -1) { score = side == "SHORT" ? 0.75: 0.25 } 
        else if (this.ms.technical_analysis[taInterval].s.a == 1)  { score = side == "LONG"  ? 0.75: 0.25 } 
        else if (this.ms.technical_analysis[taInterval].s.a == 2)  { score = side == "LONG"  ? 1: 0 }

        // Finally, return the score
        return this.weights[`ta_${taInterval}`] * score;
    }




    /**
     * Calculates the open interest HP based on the difference between
     * the initial value and the current one.
     * @param side 
     * @param initialValue 
     * @returns number
     */
    private evaluateOpenInterest(side: IBinancePositionSide, initialValue: number): number {
        // Init the score
        let score: number = 0.5;

        // Initialize the current open interest value
        const current: number = this.ms.open_interest.interest.at(-1);

        // Evaluate an open interest that is increasing
        if (current > initialValue) {
            if        (current >= this._utils.alterNumberByPercentage(initialValue, 10)) {
                score = side == "LONG" ? 1: 0;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 9.5)) {
                score = side == "LONG" ? 0.97: 0.03;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 9)) {
                score = side == "LONG" ? 0.94: 0.06;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 8.5)) {
                score = side == "LONG" ? 0.91: 0.09;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 8)) {
                score = side == "LONG" ? 0.88: 0.12;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 7.5)) {
                score = side == "LONG" ? 0.85: 0.15;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 7)) {
                score = side == "LONG" ? 0.82: 0.18;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 6.5)) {
                score = side == "LONG" ? 0.79: 0.21;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 6)) {
                score = side == "LONG" ? 0.76: 0.24;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 5.5)) {
                score = side == "LONG" ? 0.73: 0.27;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 5)) {
                score = side == "LONG" ? 0.70: 0.30;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 4.5)) {
                score = side == "LONG" ? 0.67: 0.33;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 4)) {
                score = side == "LONG" ? 0.64: 0.36;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 3.5)) {
                score = side == "LONG" ? 0.61: 0.39;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 3)) {
                score = side == "LONG" ? 0.60: 0.40;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 2.5)) {
                score = side == "LONG" ? 0.58: 0.42;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 2)) {
                score = side == "LONG" ? 0.56: 0.44;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 1.5)) {
                score = side == "LONG" ? 0.55: 0.45;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 1)) {
                score = side == "LONG" ? 0.54: 0.46;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 0.5)) {
                score = side == "LONG" ? 0.53: 0.47;
            }
        }

        // Evaluate an open interest that is decreasing
        else if (current < initialValue) {
            if        (current <= this._utils.alterNumberByPercentage(initialValue, -10)) {
                score = side == "SHORT" ? 1: 0;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -9.5)) {
                score = side == "SHORT" ? 0.97: 0.03;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -9)) {
                score = side == "SHORT" ? 0.94: 0.06;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -8.5)) {
                score = side == "SHORT" ? 0.91: 0.09;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -8)) {
                score = side == "SHORT" ? 0.88: 0.12;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -7.5)) {
                score = side == "SHORT" ? 0.85: 0.15;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -7)) {
                score = side == "SHORT" ? 0.82: 0.18;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -6.5)) {
                score = side == "SHORT" ? 0.79: 0.21;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -6)) {
                score = side == "SHORT" ? 0.76: 0.24;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -5.5)) {
                score = side == "SHORT" ? 0.73: 0.27;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -5)) {
                score = side == "SHORT" ? 0.70: 0.30;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -4.5)) {
                score = side == "SHORT" ? 0.67: 0.33;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -4)) {
                score = side == "SHORT" ? 0.64: 0.36;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -3.5)) {
                score = side == "SHORT" ? 0.61: 0.39;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -3)) {
                score = side == "SHORT" ? 0.60: 0.40;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -2.5)) {
                score = side == "SHORT" ? 0.58: 0.42;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -2)) {
                score = side == "SHORT" ? 0.56: 0.44;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -1.5)) {
                score = side == "SHORT" ? 0.55: 0.45;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -1)) {
                score = side == "SHORT" ? 0.54: 0.46;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -0.5)) {
                score = side == "SHORT" ? 0.53: 0.47;
            }
        }

        // Finally, return the score
        return this.weights.open_interest * score;
    }




    /**
     * Calculates the open interest HP based on the current state.
     * @param side 
     * @returns number
     */
    private evaluateOpenInterestState(side: IBinancePositionSide): number {
        // Init the score
        let score: number = 0.5;

        // Evaluate the current state score based on the side
        if      (this.ms.open_interest.state == 2)  { score = side == "LONG"  ? 1: 0 } 
        else if (this.ms.open_interest.state == 1)  { score = side == "LONG"  ? 0.75: 0.25 } 
        else if (this.ms.open_interest.state == -1) { score = side == "SHORT" ? 0.75: 0.25 } 
        else if (this.ms.open_interest.state == -2) { score = side == "SHORT" ? 1: 0 }

        // Finally, return the score
        return this.weights.open_interest_state * score;
    }
    




    /**
     * Calculates the long/short ratio HP based on the difference between
     * the initial value and the current one.
     * @param side 
     * @param initialValue 
     * @returns number
     */
    private evaluateLongShortRatio(side: IBinancePositionSide, initialValue: number): number {
        // Init the score
        let score: number = 0.5;

        // Initialize the current long/short ratio value
        const current: number = this.ms.long_short_ratio.ratio.at(-1);

        // Evaluate a long/short ratio that is increasing
        if (current > initialValue) {
            if        (current >= this._utils.alterNumberByPercentage(initialValue, 20)) {
                score = side == "LONG" ? 1: 0;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 19)) {
                score = side == "LONG" ? 0.97: 0.03;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 18)) {
                score = side == "LONG" ? 0.94: 0.06;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 17)) {
                score = side == "LONG" ? 0.91: 0.09;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 16)) {
                score = side == "LONG" ? 0.88: 0.12;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 15)) {
                score = side == "LONG" ? 0.85: 0.15;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 14)) {
                score = side == "LONG" ? 0.82: 0.18;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 13)) {
                score = side == "LONG" ? 0.79: 0.21;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 12)) {
                score = side == "LONG" ? 0.76: 0.24;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 11)) {
                score = side == "LONG" ? 0.73: 0.27;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 10)) {
                score = side == "LONG" ? 0.70: 0.30;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 9)) {
                score = side == "LONG" ? 0.67: 0.33;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 8)) {
                score = side == "LONG" ? 0.64: 0.36;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 7)) {
                score = side == "LONG" ? 0.61: 0.39;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 6)) {
                score = side == "LONG" ? 0.60: 0.40;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 5)) {
                score = side == "LONG" ? 0.58: 0.42;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 4)) {
                score = side == "LONG" ? 0.56: 0.44;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 3)) {
                score = side == "LONG" ? 0.55: 0.45;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 2)) {
                score = side == "LONG" ? 0.54: 0.46;
            } else if (current >= this._utils.alterNumberByPercentage(initialValue, 1)) {
                score = side == "LONG" ? 0.53: 0.47;
            }
        }

        // Evaluate a long/short ratio that is decreasing
        else if (current < initialValue) {
            if        (current <= this._utils.alterNumberByPercentage(initialValue, -20)) {
                score = side == "SHORT" ? 1: 0;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -19)) {
                score = side == "SHORT" ? 0.97: 0.03;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -18)) {
                score = side == "SHORT" ? 0.94: 0.06;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -17)) {
                score = side == "SHORT" ? 0.91: 0.09;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -16)) {
                score = side == "SHORT" ? 0.88: 0.12;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -15)) {
                score = side == "SHORT" ? 0.85: 0.15;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -14)) {
                score = side == "SHORT" ? 0.82: 0.18;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -13)) {
                score = side == "SHORT" ? 0.79: 0.21;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -12)) {
                score = side == "SHORT" ? 0.76: 0.24;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -11)) {
                score = side == "SHORT" ? 0.73: 0.27;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -10)) {
                score = side == "SHORT" ? 0.70: 0.30;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -9)) {
                score = side == "SHORT" ? 0.67: 0.33;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -8)) {
                score = side == "SHORT" ? 0.64: 0.36;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -7)) {
                score = side == "SHORT" ? 0.61: 0.39;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -6)) {
                score = side == "SHORT" ? 0.60: 0.40;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -5)) {
                score = side == "SHORT" ? 0.58: 0.42;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -4)) {
                score = side == "SHORT" ? 0.56: 0.44;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -3)) {
                score = side == "SHORT" ? 0.55: 0.45;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -2)) {
                score = side == "SHORT" ? 0.54: 0.46;
            } else if (current <= this._utils.alterNumberByPercentage(initialValue, -1)) {
                score = side == "SHORT" ? 0.53: 0.47;
            }
        }

        // Finally, return the score
        return this.weights.long_short_ratio * score;
    }




    /**
     * Calculates the long short ratio HP based on the current state.
     * @param side 
     * @returns number
     */
    private evaluateLongShortRatioState(side: IBinancePositionSide): number {
        // Init the score
        let score: number = 0.5;

        // Evaluate the current state score based on the side
        if      (this.ms.long_short_ratio.state == 2)  { score = side == "LONG"  ? 1: 0 } 
        else if (this.ms.long_short_ratio.state == 1)  { score = side == "LONG"  ? 0.75: 0.25 } 
        else if (this.ms.long_short_ratio.state == -1) { score = side == "SHORT" ? 0.75: 0.25 } 
        else if (this.ms.long_short_ratio.state == -2) { score = side == "SHORT" ? 1: 0 }

        // Finally, return the score
        return this.weights.long_short_ratio_state * score;
    }









    /**
     * Calculates the volume direction HP based on the current state.
     * @param side 
     * @returns number
     */
    private evaluateVolumeDirection(side: IBinancePositionSide): number {
        // Init the score
        let score: number = 0.5;

        // Evaluate the direction based on the current volume state
        if (this.ms.volume.state == 2) {
            if      (this.ms.volume.direction == 2)  { score = side == "LONG"  ? 1: 0 } 
            else if (this.ms.volume.direction == 1)  { score = side == "LONG"  ? 0.75: 0.25 } 
            else if (this.ms.volume.direction == -1) { score = side == "SHORT" ? 0.75: 0.25 } 
            else if (this.ms.volume.direction == -2) { score = side == "SHORT" ? 1: 0 }
        } else if (this.ms.volume.state == 1) {
            if      (this.ms.volume.direction == 2)  { score = side == "LONG"  ? 0.85: 0.15 } 
            else if (this.ms.volume.direction == 1)  { score = side == "LONG"  ? 0.65: 0.35 } 
            else if (this.ms.volume.direction == -1) { score = side == "SHORT" ? 0.65: 0.35 } 
            else if (this.ms.volume.direction == -2) { score = side == "SHORT" ? 0.85: 0.15 }
        } else {
            if      (this.ms.volume.direction == 2)  { score = side == "LONG"  ? 0.75: 0.25 } 
            else if (this.ms.volume.direction == 1)  { score = side == "LONG"  ? 0.60: 0.40 } 
            else if (this.ms.volume.direction == -1) { score = side == "SHORT" ? 0.60: 0.40 } 
            else if (this.ms.volume.direction == -2) { score = side == "SHORT" ? 0.75: 0.25 }
        }

        // Finally, return the score
        return this.weights.volume_direction * score;
    }
















    /***************************
     * Position Health Weights *
     ***************************/






    /**
     * Loads the weights from the database into the local property.
     * In case the module has not been initialized, it stores and 
     * activates the default weights.
     */
    private async initializeWeights(): Promise<void> {
        this.weights = await this._model.getHealthWeights();
        if (!this.weights) {
            this.weights = this.buildDefaultWeights();
            await this._model.createHealthWeights(this.weights);
        }
    }






    /**
     * Builds the default position health weights to be stored
     * in case the module had not yet been initialized.
     * @returns IPositionHealthWeights
     */
    private buildDefaultWeights(): IPositionHealthWeights {
        return {
            trend_sum: 35,
            trend_state: 10,
            ta_15m: 4,
            ta_30m: 4,
            ta_1h: 4,
            ta_2h: 4,
            ta_4h: 4,
            ta_1d: 4,
            open_interest: 7,
            open_interest_state: 6,
            long_short_ratio: 7,
            long_short_ratio_state: 6,
            volume_direction: 5
        }
    }






    /**
     * Updates the current weights on the database and the local
     * property.
     * @param newWeights 
     * @returns Promise<void> 
     */
    public async updateWeights(newWeights: IPositionHealthWeights): Promise<void> {
        // Validate the request
        this._validations.canPositionHealthWeightsBeUpdated(newWeights);

        // Update the weights in the db and the local property
        await this._model.updateHealthWeights(newWeights);
        this.weights = newWeights;
    }




















    /********************************
     * Position Health Candlesticks *
     ********************************/








    /**
     * Retrieves the Position HP Candlesticks for a 
     * given side. The active candlestick is also appended to
     * the list if possible.
     * @param side 
     * @returns Promise<IPositionHealthCandlestickRecord[]>
     */
    public async getPositionHealthCandlesticks(side: IBinancePositionSide): Promise<IPositionHealthCandlestickRecord[]> {
        // Make sure the provided side is valid
        this._validations.validatePositionSide(side);

        // Retrieve the candlestick records from the db
        let candlesticks: IPositionHealthCandlestickRecord[] = await this._model.getPositionHealthCandlesticks(side);

        // Append the active long if applies
        if (side == "LONG" && this.longCandlestick.ot) {
            candlesticks.push(this.buildCandlestickRecord(this.longCandlestick));
        }

        // Append the active short if applies
        if (side == "SHORT" && this.shortCandlestick.ot) {
            candlesticks.push(this.buildCandlestickRecord(this.shortCandlestick));
        }

        // Finally, return the records
        return candlesticks;
    }







    /**
     * Whenever the position health is refreshed and the health is 
     * recalculated, the candlesticks are also refreshed and 
     * stored if applies.
     * @returns Promise<void>
     */
    private async processCandlesticks(): Promise<void> {
        // Init the time
        const ts: number = Date.now();

        // Update the long candlesticks (if any)
        if (this.long) {
            // If there isn't an active candlestick, build the initial one
            if (!this.longCandlestick.ot) {
                this.longCandlestick = {
                    ot: ts,
                    hp: { o: this.long.chp, h: this.long.chp, l: this.long.chp, c: this.long.chp },
                    dd: { o: this.long.dd, h: this.long.dd, l: this.long.dd, c: this.long.dd },
                    mgdd: { o: this.long.mgdd, h: this.long.mgdd, l: this.long.mgdd, c: this.long.mgdd },
                }
            }

            // Otherwise, update the active candlestick
            else {
                this.longCandlestick = {
                    ot: this.longCandlestick.ot,
                    hp: {
                        o: this.longCandlestick.hp.o,
                        h: this.long.chp > this.longCandlestick.hp.h ? this.long.chp: this.longCandlestick.hp.h,
                        l: this.long.chp < this.longCandlestick.hp.l ? this.long.chp: this.longCandlestick.hp.l,
                        c: this.long.chp
                    },
                    dd: {
                        o: this.longCandlestick.dd.o,
                        h: this.long.dd > this.longCandlestick.dd.h ? this.long.dd: this.longCandlestick.dd.h,
                        l: this.long.dd < this.longCandlestick.dd.l ? this.long.dd: this.longCandlestick.dd.l,
                        c: this.long.dd
                    },
                    mgdd: {
                        o: this.longCandlestick.mgdd.o,
                        h: this.long.mgdd > this.longCandlestick.mgdd.h ? this.long.mgdd: this.longCandlestick.mgdd.h,
                        l: this.long.mgdd < this.longCandlestick.mgdd.l ? this.long.mgdd: this.longCandlestick.mgdd.l,
                        c: this.long.mgdd
                    }
                }

                /**
                 * If the candlestick's close time has been reached, store it and 
                 * build the next one.
                 */
                const closeTime: number = this.calculateCandlestickCloseTime(this.longCandlestick.ot);
                if (ts >= closeTime) {
                    await this._model.savePositionHealthCandlestick("LONG", this.buildCandlestickRecord(this.longCandlestick));
                    this.longCandlestick = {
                        ot: ts,
                        hp: { o: this.long.chp, h: this.long.chp, l: this.long.chp, c: this.long.chp },
                        dd: { o: this.long.dd, h: this.long.dd, l: this.long.dd, c: this.long.dd },
                        mgdd: { o: this.long.mgdd, h: this.long.mgdd, l: this.long.mgdd, c: this.long.mgdd },
                    }
                }
            }
        }

        // Update the short candlesticks (if any)
        if (this.short) {
            // If there isn't an active candlestick, build the initial one
            if (!this.shortCandlestick.ot) {
                this.shortCandlestick = {
                    ot: ts,
                    hp: { o: this.short.chp, h: this.short.chp, l: this.short.chp, c: this.short.chp },
                    dd: { o: this.short.dd, h: this.short.dd, l: this.short.dd, c: this.short.dd },
                    mgdd: { o: this.short.mgdd, h: this.short.mgdd, l: this.short.mgdd, c: this.short.mgdd },
                }
            }

            // Otherwise, update the active candlestick
            else {
                this.shortCandlestick = {
                    ot: this.shortCandlestick.ot,
                    hp: {
                        o: this.shortCandlestick.hp.o,
                        h: this.short.chp > this.shortCandlestick.hp.h ? this.short.chp: this.shortCandlestick.hp.h,
                        l: this.short.chp < this.shortCandlestick.hp.l ? this.short.chp: this.shortCandlestick.hp.l,
                        c: this.short.chp
                    },
                    dd: {
                        o: this.shortCandlestick.dd.o,
                        h: this.short.dd > this.shortCandlestick.dd.h ? this.short.dd: this.shortCandlestick.dd.h,
                        l: this.short.dd < this.shortCandlestick.dd.l ? this.short.dd: this.shortCandlestick.dd.l,
                        c: this.short.dd
                    },
                    mgdd: {
                        o: this.shortCandlestick.mgdd.o,
                        h: this.short.mgdd > this.shortCandlestick.mgdd.h ? this.short.mgdd: this.shortCandlestick.mgdd.h,
                        l: this.short.mgdd < this.shortCandlestick.mgdd.l ? this.short.mgdd: this.shortCandlestick.mgdd.l,
                        c: this.short.mgdd
                    }
                }

                /**
                 * If the candlestick's close time has been reached, store it and 
                 * build the next one.
                 */
                const closeTime: number = this.calculateCandlestickCloseTime(this.shortCandlestick.ot);
                if (ts >= closeTime) {
                    await this._model.savePositionHealthCandlestick("SHORT", this.buildCandlestickRecord(this.shortCandlestick));
                    this.shortCandlestick = {
                        ot: ts,
                        hp: { o: this.short.chp, h: this.short.chp, l: this.short.chp, c: this.short.chp },
                        dd: { o: this.short.dd, h: this.short.dd, l: this.short.dd, c: this.short.dd },
                        mgdd: { o: this.short.mgdd, h: this.short.mgdd, l: this.short.mgdd, c: this.short.mgdd },
                    }
                }
            }
        }
    }









    /**
     * Cleans the position candlesticks in case a position
     * is no longer active.
     * @returns Promise<void>
     */
    private async cleanCandlesticks(side: IBinancePositionSide): Promise<void> {
        // Delete the candlesticks from the db
        await this._model.cleanPositionHealthCandlesticks(side);

        // Delete the candlesticks from the local property
        if (side == "LONG") {
            this.longCandlestick = { ot: undefined, hp: undefined, dd: undefined, mgdd: undefined };
        } else {
            this.shortCandlestick = { ot: undefined, hp: undefined, dd: undefined, mgdd: undefined };
        }
    }







    /* Misc HP Candlestick Helpers */






    /**
     * Calculates the close time of a candlestick based on
     * the time it was opened.
     * @param openTime 
     * @returns number
     */
    private calculateCandlestickCloseTime(openTime: number): number { 
        return moment(openTime).add(this.candlestickIntervalMinutes, "minutes").valueOf() - 1;
    }







    /**
     * Converts an active candlestick into a record.
     * @param active 
     * @returns IPositionHealthCandlestickRecord
     */
    private buildCandlestickRecord(active: IPositionHealthActiveCandlestick): IPositionHealthCandlestickRecord {
        return {
            ot: active.ot,
            d: {
                o: [active.hp.o, active.dd.o, active.mgdd.o ],
                h: [active.hp.h, active.dd.h, active.mgdd.h ],
                l: [active.hp.l, active.dd.l, active.mgdd.l ],
                c: [active.hp.c, active.dd.c, active.mgdd.c ],
            }
        }
    }
}
