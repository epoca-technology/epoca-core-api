import {inject, injectable} from "inversify";
import { Subscription } from "rxjs";
import * as moment from "moment";
import { SYMBOLS } from "../../ioc";
import { IPrediction } from "../epoch-builder";
import { IPredictionService } from "../prediction";
import { IMarketState, IMarketStateService, ITAIntervalID } from "../market-state";
import { IBinancePositionSide } from "../binance";
import { IUtilitiesService } from "../utilities";
import { 
    IPositionHealth,
    IPositionModel,
    IPositionSideHealth,
    IPositionHealthState,
    IPositionHealthWeights,
    IActivePosition,
    IPositionHealthCandlestick,
    IPositionHealthCandlesticks,
    IPositionHealthActiveCandlesticks
} from "./interfaces";




@injectable()
export class PositionHealth implements IPositionHealth {
    // Inject dependencies
    @inject(SYMBOLS.PredictionService)          private _prediction: IPredictionService;
    @inject(SYMBOLS.MarketStateService)         private _marketState: IMarketStateService;
    @inject(SYMBOLS.PositionModel)              private _model: IPositionModel;
    @inject(SYMBOLS.UtilitiesService)           private _utils: IUtilitiesService;


    /**
     * Position Health Weights
     * The weights used by each module in order to calculate the 
     * position's health points.
     */
    private readonly weights: IPositionHealthWeights = {
        trend_sum: 50,
        trend_state: 7.5,
        ta_30m: 3.5,
        ta_1h: 4,
        ta_2h: 5,
        ta_4h: 6,
        ta_1d: 7,
        open_interest: 7.5,
        long_short_ratio: 7.5,
        volume_direction: 2
    }


    /**
     * Long Position Health
     * The active long position's health, if none is, this value is undefined.
     */
    public long: IPositionSideHealth|null = null;



    /**
     * Short Position Health
     * The active short position's health, if none is, this value is undefined.
     */
    public short: IPositionSideHealth|null = null;


    /**
     * Prediction Stream
     * Real time connection to the predictions generated by the PredictionModel.
     */
    private pred: IPrediction|undefined;
    private predSub: Subscription;


    /**
     * Market State Stream
     * Real time connection to the current market state.
     */
    private ms: IMarketState;
    private msSub: Subscription;


    /**
     * Position Health Candlesticks
     * The candlesticks are initially built in RAM and only stored in disk
     * once the candlestick ends.
     * When retrieving candlesticks, the active one is appended to the 
     * list stored in the disk.
     */
    private longCandlesticks: IPositionHealthActiveCandlesticks = {
        hp: undefined,
        dd: undefined
    }
    private shortCandlesticks: IPositionHealthActiveCandlesticks = {
        hp: undefined,
        dd: undefined
    }
    private readonly candlestickIntervalMinutes: number = 30;




    constructor() {}










    /***************
     * Initializer * 
     ***************/





    /**
     * Initializes the Position Health Module.
     * @returns Promise<void>
     */
    public async initialize(): Promise<void> {
        // Subscribe the to prediction stream
        this.predSub = this._prediction.active.subscribe((pred: IPrediction|undefined) => {
            this.pred = pred;
        });

        // Subscribe to the market state stream
        this.msSub = this._marketState.active.subscribe((ms: IMarketState) => {
            this.ms = ms;
        });

        // Initialize the stored health
        const health: IPositionHealthState|undefined = await this._model.getHealth();
        if (health) {
            this.long = health.long;
            this.short = health.short;
        } else {
            await this._model.createHealth({long: this.long, short: this.short});
        }
    }




    /**
     * Stops the subscriptions too all the external modules.
     */
    public stop(): void {
        if (this.predSub) this.predSub.unsubscribe();
        if (this.msSub) this.msSub.unsubscribe();
    }


    
















    /******************************
     * Position Health Calculator *
     ******************************/









    /**
     * Calculates the health for all active positions.
     * @param long 
     * @param short 
     * @returns Promise<void>
     */
    public async onPositionRefresh(
        long: IActivePosition|undefined,
        short: IActivePosition|undefined
    ): Promise<void> {
        // Make sure the prediction and the market state are properly set
        if (!this.pred) {
            console.log(this.pred);
            throw new Error(this._utils.buildApiError(`The position health could not be calculated because the 
            prediction model is not currently active.`, 32000));
        }
        if (!this.ms) {
            console.log(this.ms);
            throw new Error(this._utils.buildApiError(`The position health could not be calculated because the 
            market state is not currently active.`, 32001));
        }

        // Evaluate the long position (if any)
        if (long) {
            this.long = this.calculateHealth("LONG");
        } else { this.long = null }

        // Evaluate the short position (if any)
        if (short) {
            this.short = this.calculateHealth("SHORT");
        } else { this.short = null }

        // Update the state on the db
        await this._model.updateHealth({long: this.long, short: this.short});

        // Finally, process the candlesticks
        await this.processCandlesticks();
    }







    /**
     * Creates or updates the health for a position side.
     * @param side 
     * @returns IPositionSideHealth
     */
    private calculateHealth(side: IBinancePositionSide): IPositionSideHealth {
        // Firstly, initialize the side's health in case it hasn't been
        let health: IPositionSideHealth|null = side == "LONG" ? this.long: this.short;
        if (!health) {
            health = {
                os: this.pred.s,
                ohp: 0,
                hhp: 0,
                lhp: 0,
                chp: 0,
                dd: 0,
                ts: Date.now()
            }
        }

        // Init the health points
        let hp: number = 0;

        // Evaluate the trend sum
        hp += this.evaluateTrendSum(side, health.os);

        // Evaluate the trend state
        hp += this.evaluateTrendState(side);

        // Evaluate the TA
        hp += this.evaluateTechnicalAnalysis(side, "30m"); 
        hp += this.evaluateTechnicalAnalysis(side, "1h"); 
        hp += this.evaluateTechnicalAnalysis(side, "2h"); 
        hp += this.evaluateTechnicalAnalysis(side, "4h"); 
        hp += this.evaluateTechnicalAnalysis(side, "1d"); 

        // Evaluate the open interest
        hp += this.evaluateOpenInterest(side);

        // Evaluate the long/short ratio
        hp += this.evaluateLongShortRatio(side);

        // Evaluate the volume direction
        hp += this.evaluateVolumeDirection(side);

        // Format the HP correctly
        hp = <number>this._utils.outputNumber(hp);

        // Complete the health object if it was partially initialized
        if (health.ohp == 0) {
            health.ohp = hp;
            health.hhp = hp;
            health.lhp = hp;
            health.chp = hp;
        }

        // Otherwise, update the health point related properties
        else {
            health.hhp = hp > health.hhp ? hp: health.hhp;
            health.lhp = hp < health.lhp ? hp: health.lhp;
            health.chp = hp;
        }

        /**
         * For there to be a drawdown, the current health must be less than the highest.
         * Otherwise, the drawdown is equals to 0.
         */
        if (health.hhp > health.chp) {
            health.dd = <number>this._utils.calculatePercentageChange(health.hhp, health.chp);
        } else { health.dd = 0 }

        // Finally, return the current health
        return health;
    }





    /**
     * Calculates the prediction HP based on the initial and the current
     * sum.
     * @param side 
     * @param openSum 
     * @returns number
     */
    private evaluateTrendSum(side: IBinancePositionSide, openSum: number): number {
        // Init the score
        let score: number = 0.5;

        // Evaluate a trend sum that is increasing
        if (this.pred.s > openSum) {
            const alterMultiplier: number = openSum > 0 ? 1: -1;
            if        (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 95*alterMultiplier)) {
                score = side == "LONG" ? 1: 0;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 93*alterMultiplier)) {
                score = side == "LONG" ? 0.98: 0.02;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 91*alterMultiplier)) {
                score = side == "LONG" ? 0.96: 0.04;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 89*alterMultiplier)) {
                score = side == "LONG" ? 0.95: 0.05;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 87*alterMultiplier)) {
                score = side == "LONG" ? 0.94: 0.06;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 85*alterMultiplier)) {
                score = side == "LONG" ? 0.93: 0.07;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 83*alterMultiplier)) {
                score = side == "LONG" ? 0.92: 0.08;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 81*alterMultiplier)) {
                score = side == "LONG" ? 0.91: 0.09;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 79*alterMultiplier)) {
                score = side == "LONG" ? 0.90: 0.10;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 77*alterMultiplier)) {
                score = side == "LONG" ? 0.89: 0.11;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 75*alterMultiplier)) {
                score = side == "LONG" ? 0.88: 0.12;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 73*alterMultiplier)) {
                score = side == "LONG" ? 0.87: 0.13;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 71*alterMultiplier)) {
                score = side == "LONG" ? 0.86: 0.14;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 69*alterMultiplier)) {
                score = side == "LONG" ? 0.85: 0.15;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 67*alterMultiplier)) {
                score = side == "LONG" ? 0.84: 0.16;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 65*alterMultiplier)) {
                score = side == "LONG" ? 0.83: 0.17;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 63*alterMultiplier)) {
                score = side == "LONG" ? 0.82: 0.18;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 61*alterMultiplier)) {
                score = side == "LONG" ? 0.81: 0.19;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 59*alterMultiplier)) {
                score = side == "LONG" ? 0.80: 0.20;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 57*alterMultiplier)) {
                score = side == "LONG" ? 0.79: 0.21;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 55*alterMultiplier)) {
                score = side == "LONG" ? 0.78: 0.22;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 53*alterMultiplier)) {
                score = side == "LONG" ? 0.77: 0.23;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 51*alterMultiplier)) {
                score = side == "LONG" ? 0.76: 0.24;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 49*alterMultiplier)) {
                score = side == "LONG" ? 0.75: 0.25;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 47*alterMultiplier)) {
                score = side == "LONG" ? 0.74: 0.26;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 45*alterMultiplier)) {
                score = side == "LONG" ? 0.73: 0.27;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 43*alterMultiplier)) {
                score = side == "LONG" ? 0.72: 0.28;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 41*alterMultiplier)) {
                score = side == "LONG" ? 0.71: 0.29;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 39*alterMultiplier)) {
                score = side == "LONG" ? 0.70: 0.30;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 37*alterMultiplier)) {
                score = side == "LONG" ? 0.69: 0.31;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 35*alterMultiplier)) {
                score = side == "LONG" ? 0.68: 0.32;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 33*alterMultiplier)) {
                score = side == "LONG" ? 0.67: 0.33;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 31*alterMultiplier)) {
                score = side == "LONG" ? 0.66: 0.34;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 29*alterMultiplier)) {
                score = side == "LONG" ? 0.65: 0.35;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 27*alterMultiplier)) {
                score = side == "LONG" ? 0.64: 0.36;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 25*alterMultiplier)) {
                score = side == "LONG" ? 0.63: 0.37;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 23*alterMultiplier)) {
                score = side == "LONG" ? 0.62: 0.38;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 21*alterMultiplier)) {
                score = side == "LONG" ? 0.61: 0.39;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 19*alterMultiplier)) {
                score = side == "LONG" ? 0.60: 0.40;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 17*alterMultiplier)) {
                score = side == "LONG" ? 0.59: 0.41;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 15*alterMultiplier)) {
                score = side == "LONG" ? 0.58: 0.42;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 13*alterMultiplier)) {
                score = side == "LONG" ? 0.57: 0.43;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 11*alterMultiplier)) {
                score = side == "LONG" ? 0.56: 0.44;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 9*alterMultiplier)) {
                score = side == "LONG" ? 0.55: 0.45;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 7*alterMultiplier)) {
                score = side == "LONG" ? 0.54: 0.46;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 5*alterMultiplier)) {
                score = side == "LONG" ? 0.53: 0.47;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 3*alterMultiplier)) {
                score = side == "LONG" ? 0.52: 0.48;
            } else if (this.pred.s >= this._utils.alterNumberByPercentage(openSum, 1*alterMultiplier)) {
                score = side == "LONG" ? 0.51: 0.49;
            }
        }

        // Evaluate a trend sum that is decreasing
        else if (this.pred.s < openSum) {
            const alterMultiplier: number = openSum < 0 ? 1: -1;
            if        (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 95*alterMultiplier)) {
                score = side == "SHORT" ? 1: 0;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 93*alterMultiplier)) {
                score = side == "SHORT" ? 0.98: 2;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 91*alterMultiplier)) {
                score = side == "SHORT" ? 0.96: 4;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 89*alterMultiplier)) {
                score = side == "SHORT" ? 0.95: 5;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 87*alterMultiplier)) {
                score = side == "SHORT" ? 0.94: 6;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 85*alterMultiplier)) {
                score = side == "SHORT" ? 0.93: 7;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 83*alterMultiplier)) {
                score = side == "SHORT" ? 0.92: 8;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 81*alterMultiplier)) {
                score = side == "SHORT" ? 0.91: 9;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 79*alterMultiplier)) {
                score = side == "SHORT" ? 0.90: 0.10;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 77*alterMultiplier)) {
                score = side == "SHORT" ? 0.89: 0.11;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 75*alterMultiplier)) {
                score = side == "SHORT" ? 0.88: 0.12;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 73*alterMultiplier)) {
                score = side == "SHORT" ? 0.87: 0.13;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 71*alterMultiplier)) {
                score = side == "SHORT" ? 0.86: 0.14;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 69*alterMultiplier)) {
                score = side == "SHORT" ? 0.85: 0.15;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 67*alterMultiplier)) {
                score = side == "SHORT" ? 0.84: 0.16;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 65*alterMultiplier)) {
                score = side == "SHORT" ? 0.83: 0.17;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 63*alterMultiplier)) {
                score = side == "SHORT" ? 0.82: 0.18;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 61*alterMultiplier)) {
                score = side == "SHORT" ? 0.81: 0.19;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 59*alterMultiplier)) {
                score = side == "SHORT" ? 0.80: 0.20;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 57*alterMultiplier)) {
                score = side == "SHORT" ? 0.79: 0.21;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 55*alterMultiplier)) {
                score = side == "SHORT" ? 0.78: 0.22;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 53*alterMultiplier)) {
                score = side == "SHORT" ? 0.77: 0.23;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 51*alterMultiplier)) {
                score = side == "SHORT" ? 0.76: 0.24;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 49*alterMultiplier)) {
                score = side == "SHORT" ? 0.75: 0.25;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 47*alterMultiplier)) {
                score = side == "SHORT" ? 0.74: 0.26;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 45*alterMultiplier)) {
                score = side == "SHORT" ? 0.73: 0.27;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 43*alterMultiplier)) {
                score = side == "SHORT" ? 0.72: 0.28;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 41*alterMultiplier)) {
                score = side == "SHORT" ? 0.71: 0.29;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 39*alterMultiplier)) {
                score = side == "SHORT" ? 0.70: 0.30;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 37*alterMultiplier)) {
                score = side == "SHORT" ? 0.69: 0.31;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 35*alterMultiplier)) {
                score = side == "SHORT" ? 0.68: 0.32;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 33*alterMultiplier)) {
                score = side == "SHORT" ? 0.67: 0.33;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 31*alterMultiplier)) {
                score = side == "SHORT" ? 0.66: 0.34;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 29*alterMultiplier)) {
                score = side == "SHORT" ? 0.65: 0.35;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 27*alterMultiplier)) {
                score = side == "SHORT" ? 0.64: 0.36;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 25*alterMultiplier)) {
                score = side == "SHORT" ? 0.63: 0.37;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 23*alterMultiplier)) {
                score = side == "SHORT" ? 0.62: 0.38;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 21*alterMultiplier)) {
                score = side == "SHORT" ? 0.61: 0.39;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 19*alterMultiplier)) {
                score = side == "SHORT" ? 0.60: 0.40;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 17*alterMultiplier)) {
                score = side == "SHORT" ? 0.59: 0.41;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 15*alterMultiplier)) {
                score = side == "SHORT" ? 0.58: 0.42;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 13*alterMultiplier)) {
                score = side == "SHORT" ? 0.57: 0.43;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 11*alterMultiplier)) {
                score = side == "SHORT" ? 0.56: 0.44;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 9*alterMultiplier)) {
                score = side == "SHORT" ? 0.55: 0.45;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 7*alterMultiplier)) {
                score = side == "SHORT" ? 0.54: 0.46;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 5*alterMultiplier)) {
                score = side == "SHORT" ? 0.53: 0.47;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 3*alterMultiplier)) {
                score = side == "SHORT" ? 0.52: 0.48;
            } else if (this.pred.s <= this._utils.alterNumberByPercentage(openSum, 1*alterMultiplier)) {
                score = side == "SHORT" ? 0.51: 0.49;
            }
        }

        // Finally, return the score
        return this.weights.trend_sum * score;
    }





    /**
     * Calculates the prediction state HP based on the current state and side.
     * @param side 
     * @returns number
     */
    private evaluateTrendState(side: IBinancePositionSide): number {
        // Init the score
        let score: number = 0.5;

        // Evaluate an increasing trend state with low intensity
        if (this._prediction.activeState >= 9 && this._prediction.activeStateIntesity == 1) {
            score = side == "LONG" ? 0.68: 0.32;
        } else if (this._prediction.activeState == 8 && this._prediction.activeStateIntesity == 1) {
            score = side == "LONG" ? 0.66: 0.34;
        } else if (this._prediction.activeState == 7 && this._prediction.activeStateIntesity == 1) {
            score = side == "LONG" ? 0.64: 0.36;
        } else if (this._prediction.activeState == 6 && this._prediction.activeStateIntesity == 1) {
            score = side == "LONG" ? 0.62: 0.38;
        } else if (this._prediction.activeState == 5 && this._prediction.activeStateIntesity == 1) {
            score = side == "LONG" ? 0.60: 0.40;
        } else if (this._prediction.activeState == 4 && this._prediction.activeStateIntesity == 1) {
            score = side == "LONG" ? 0.58: 0.42;
        } else if (this._prediction.activeState == 3 && this._prediction.activeStateIntesity == 1) {
            score = side == "LONG" ? 0.56: 0.44;
        } else if (this._prediction.activeState == 2 && this._prediction.activeStateIntesity == 1) {
            score = side == "LONG" ? 0.54: 0.46;
        } else if (this._prediction.activeState == 1 && this._prediction.activeStateIntesity == 1) {
            score = side == "LONG" ? 0.52: 0.48;
        }

        // Evaluate an increasing trend state with high intensity
        else if (this._prediction.activeState >= 9 && this._prediction.activeStateIntesity == 2) {
            score = side == "LONG" ? 1: 0;
        } else if (this._prediction.activeState == 8 && this._prediction.activeStateIntesity == 2) {
            score = side == "LONG" ? 0.95: 0.05;
        } else if (this._prediction.activeState == 7 && this._prediction.activeStateIntesity == 2) {
            score = side == "LONG" ? 0.90: 0.10;
        } else if (this._prediction.activeState == 6 && this._prediction.activeStateIntesity == 2) {
            score = side == "LONG" ? 0.85: 0.15;
        } else if (this._prediction.activeState == 5 && this._prediction.activeStateIntesity == 2) {
            score = side == "LONG" ? 0.80: 0.20;
        } else if (this._prediction.activeState == 4 && this._prediction.activeStateIntesity == 2) {
            score = side == "LONG" ? 0.75: 0.25;
        } else if (this._prediction.activeState == 3 && this._prediction.activeStateIntesity == 2) {
            score = side == "LONG" ? 0.70: 0.30;
        } else if (this._prediction.activeState == 2 && this._prediction.activeStateIntesity == 2) {
            score = side == "LONG" ? 0.65: 0.35;
        } else if (this._prediction.activeState == 1 && this._prediction.activeStateIntesity == 2) {
            score = side == "LONG" ? 0.55: 0.45;
        }

        // Evaluate a decreasing trend state with low intensity
        else if (this._prediction.activeState == -1 && this._prediction.activeStateIntesity == -1) {
            score = side == "SHORT" ? 0.52: 0.48;
        } else if (this._prediction.activeState == -2 && this._prediction.activeStateIntesity == -1) {
            score = side == "SHORT" ? 0.54: 0.46;
        } else if (this._prediction.activeState == -3 && this._prediction.activeStateIntesity == -1) {
            score = side == "SHORT" ? 0.56: 0.44;
        } else if (this._prediction.activeState == -4 && this._prediction.activeStateIntesity == -1) {
            score = side == "SHORT" ? 0.58: 0.42;
        } else if (this._prediction.activeState == -5 && this._prediction.activeStateIntesity == -1) {
            score = side == "SHORT" ? 0.60: 0.40;
        } else if (this._prediction.activeState == -6 && this._prediction.activeStateIntesity == -1) {
            score = side == "SHORT" ? 0.62: 0.38;
        } else if (this._prediction.activeState == -7 && this._prediction.activeStateIntesity == -1) {
            score = side == "SHORT" ? 0.64: 0.36;
        } else if (this._prediction.activeState == -8 && this._prediction.activeStateIntesity == -1) {
            score = side == "SHORT" ? 0.66: 0.34;
        } else if (this._prediction.activeState <= -9 && this._prediction.activeStateIntesity == -1) {
            score = side == "SHORT" ? 0.68: 0.32;
        }

        // Evaluate a decreasing trend state with high intensity
        else if (this._prediction.activeState == -1 && this._prediction.activeStateIntesity == -2) {
            score = side == "SHORT" ? 0.55: 0.45;
        } else if (this._prediction.activeState == -2 && this._prediction.activeStateIntesity == -2) {
            score = side == "SHORT" ? 0.65: 0.35;
        } else if (this._prediction.activeState == -3 && this._prediction.activeStateIntesity == -2) {
            score = side == "SHORT" ? 0.70: 0.30;
        } else if (this._prediction.activeState == -4 && this._prediction.activeStateIntesity == -2) {
            score = side == "SHORT" ? 0.75: 0.25;
        } else if (this._prediction.activeState == -5 && this._prediction.activeStateIntesity == -2) {
            score = side == "SHORT" ? 0.80: 0.20;
        } else if (this._prediction.activeState == -6 && this._prediction.activeStateIntesity == -2) {
            score = side == "SHORT" ? 0.85: 0.15;
        } else if (this._prediction.activeState == -7 && this._prediction.activeStateIntesity == -2) {
            score = side == "SHORT" ? 0.90: 0.10;
        } else if (this._prediction.activeState == -8 && this._prediction.activeStateIntesity == -2) {
            score = side == "SHORT" ? 0.95: 0.05;
        } else if (this._prediction.activeState <= -9 && this._prediction.activeStateIntesity == -2) {
            score = side == "SHORT" ? 1: 0;
        }

        // Finally, return the score
        return this.weights.trend_state * score;
    }





    /**
     * Calculates the technical analysis HP based on the current state.
     * @param side 
     * @returns number
     */
    private evaluateTechnicalAnalysis(side: IBinancePositionSide, taInterval: ITAIntervalID): number {
        // Init the score
        let score: number = 0.5;

        // Evaluate the current state score based on the side
        if (this.ms.technical_analysis[taInterval].s.a == -2) {
            score = side == "SHORT" ? 1: 0
        } else if (this.ms.technical_analysis[taInterval].s.a == -1) {
            score = side == "SHORT" ? 0.75: 0.25
        } else if (this.ms.technical_analysis[taInterval].s.a == 1) {
            score = side == "LONG" ? 0.75: 0.25
        } else if (this.ms.technical_analysis[taInterval].s.a == 2) {
            score = side == "LONG" ? 1: 0
        }

        // Finally, return the score
        return this.weights[`ta_${taInterval}`] * score;
    }






    /**
     * Calculates the open interest HP based on the current state.
     * @param side 
     * @returns number
     */
    private evaluateOpenInterest(side: IBinancePositionSide): number {
        // Init the score
        let score: number = 0.5;

        // Evaluate the current state score based on the side
        if (this.ms.open_interest.state == 2) {
            score = side == "LONG" ? 1: 0
        } else if (this.ms.open_interest.state == 1) {
            score = side == "LONG" ? 0.75: 0.25
        } else if (this.ms.open_interest.state == -1) {
            score = side == "SHORT" ? 0.75: 0.25
        } else if (this.ms.open_interest.state == -2) {
            score = side == "SHORT" ? 1: 0
        }

        // Finally, return the score
        return this.weights.open_interest * score;
    }
    



    /**
     * Calculates the long short ratio HP based on the current state.
     * @param side 
     * @returns number
     */
    private evaluateLongShortRatio(side: IBinancePositionSide): number {
        // Init the score
        let score: number = 0.5;

        // Evaluate the current state score based on the side
        if (this.ms.long_short_ratio.state == 2) {
            score = side == "LONG" ? 1: 0
        } else if (this.ms.long_short_ratio.state == 1) {
            score = side == "LONG" ? 0.75: 0.25
        } else if (this.ms.long_short_ratio.state == -1) {
            score = side == "SHORT" ? 0.75: 0.25
        } else if (this.ms.long_short_ratio.state == -2) {
            score = side == "SHORT" ? 1: 0
        }

        // Finally, return the score
        return this.weights.long_short_ratio * score;
    }









    /**
     * Calculates the volume direction HP based on the current state.
     * @param side 
     * @returns number
     */
    private evaluateVolumeDirection(side: IBinancePositionSide): number {
        // Init the score
        let score: number = 0.5;

        // Evaluate the current state score based on the side
        if (this.ms.volume.direction == 2) {
            score = side == "LONG" ? 1: 0
        } else if (this.ms.volume.direction == 1) {
            score = side == "LONG" ? 0.75: 0.25
        } else if (this.ms.volume.direction == -1) {
            score = side == "SHORT" ? 0.75: 0.25
        } else if (this.ms.volume.direction == -2) {
            score = side == "SHORT" ? 1: 0
        }

        // Finally, return the score
        return this.weights.volume_direction * score;
    }











    /********************************
     * Position Health Candlesticks *
     ********************************/








    /**
     * Retrieves the Position HP & Drawdown candlesticks for a 
     * given side. The active candlestick is also appended to
     * the list if possible.
     * @param side 
     * @returns Promise<IPositionHealthCandlesticks>
     */
    public async getPositionHealthCandlesticks(side: IBinancePositionSide): Promise<IPositionHealthCandlesticks> {
        // Make sure the provided side is valid
        if (side != "LONG" && side != "SHORT") {
            throw new Error(this._utils.buildApiError(`The position health candlesticks cannot be retrieved because 
            the provided side is invalid. Received: ${side}`, 32002));
        }

        // Retrieve the candlesticks from the db
        let { hp, dd } = await this._model.getPositionHealthCandlesticks(side);

        // Append the active long if applies
        if (side == "LONG" && this.longCandlesticks.hp && this.longCandlesticks.dd) {
            hp.push(this.longCandlesticks.hp);
            dd.push(this.longCandlesticks.dd);
        }

        // Append the active short if applies
        if (side == "SHORT" && this.shortCandlesticks.hp && this.shortCandlesticks.dd) {
            hp.push(this.shortCandlesticks.hp);
            dd.push(this.shortCandlesticks.dd);
        }

        // Finally, pack and return the candlesticks
        return { hp: hp, dd: dd };
    }







    /**
     * Whenever the positions are refreshed and the health is 
     * recalculated, the candlesticks are also refreshed and 
     * stored if applies.
     * @returns Promise<void>
     */
    private async processCandlesticks(): Promise<void> {
        // Firstly, clean the candlesticks for the sides that are not active
        await this.cleanCandlesticks();

        // Init the time
        const ts: number = Date.now();

        // Update the long candlesticks (if any)
        if (this.long) {
            // If there aren't any candlesticks, build the initial one
            if (!this.longCandlesticks.hp && !this.longCandlesticks.dd) {
                this.longCandlesticks = {
                    hp: this.buildNewCandlestick(ts, this.long.chp),
                    dd: this.buildNewCandlestick(ts, this.long.dd)
                }
            }

            // Otherwise, update the active candlestick
            else {
                this.longCandlesticks = {
                    hp: {
                        ot: this.longCandlesticks.hp.ot,
                        o: this.longCandlesticks.hp.o,
                        h: this.long.chp > this.longCandlesticks.hp.h ? this.long.chp: this.longCandlesticks.hp.h,
                        l: this.long.chp < this.longCandlesticks.hp.l ? this.long.chp: this.longCandlesticks.hp.l,
                        c: this.long.chp
                    },
                    dd: {
                        ot: this.longCandlesticks.dd.ot,
                        o: this.longCandlesticks.dd.o,
                        h: this.long.dd > this.longCandlesticks.dd.h ? this.long.dd: this.longCandlesticks.dd.h,
                        l: this.long.dd < this.longCandlesticks.dd.l ? this.long.dd: this.longCandlesticks.dd.l,
                        c: this.long.dd
                    }
                }

                /**
                 * If the candlestick's close time has been reached, store it and 
                 * build the next one.
                 */
                const closeTime: number = this.calculateCandlestickCloseTime(this.longCandlesticks.hp.ot);
                if (ts >= closeTime) {
                    await this._model.savePositionHealthCandlesticks(
                        "LONG",
                        this.longCandlesticks.hp,
                        this.longCandlesticks.dd
                    );
                    this.longCandlesticks = {
                        hp: this.buildNewCandlestick(ts, this.long.chp),
                        dd: this.buildNewCandlestick(ts, this.long.dd)
                    }
                }
            }
        }

        // Update the short candlesticks (if any)
        if (this.short) {
            // If there aren't any candlesticks, build the initial one
            if (!this.shortCandlesticks.hp && !this.shortCandlesticks.dd) {
                this.shortCandlesticks = {
                    hp: this.buildNewCandlestick(ts, this.short.chp),
                    dd: this.buildNewCandlestick(ts, this.short.dd)
                }
            }

            // Otherwise, update the active candlestick
            else {
                this.shortCandlesticks = {
                    hp: {
                        ot: this.shortCandlesticks.hp.ot,
                        o: this.shortCandlesticks.hp.o,
                        h: this.short.chp > this.shortCandlesticks.hp.h ? this.short.chp: this.shortCandlesticks.hp.h,
                        l: this.short.chp < this.shortCandlesticks.hp.l ? this.short.chp: this.shortCandlesticks.hp.l,
                        c: this.short.chp
                    },
                    dd: {
                        ot: this.shortCandlesticks.dd.ot,
                        o: this.shortCandlesticks.dd.o,
                        h: this.short.dd > this.shortCandlesticks.dd.h ? this.short.dd: this.shortCandlesticks.dd.h,
                        l: this.short.dd < this.shortCandlesticks.dd.l ? this.short.dd: this.shortCandlesticks.dd.l,
                        c: this.short.dd
                    }
                }

                /**
                 * If the candlestick's close time has been reached, store it and 
                 * build the next one.
                 */
                const closeTime: number = this.calculateCandlestickCloseTime(this.shortCandlesticks.hp.ot);
                if (ts >= closeTime) {
                    await this._model.savePositionHealthCandlesticks(
                        "SHORT",
                        this.shortCandlesticks.hp,
                        this.shortCandlesticks.dd
                    );
                    this.shortCandlesticks = {
                        hp: this.buildNewCandlestick(ts, this.short.chp),
                        dd: this.buildNewCandlestick(ts, this.short.dd)
                    }
                }
            }
        }
    }









    /**
     * Builds a new candlestick based on the current value.
     * @param currentTime
     * @param value
     * @returns IPositionHealthCandlestick
     */
    private buildNewCandlestick(currentTime: number, value: number): IPositionHealthCandlestick {
        return { ot: currentTime, o: value, h: value, l: value, c: value }
    }






    /**
     * Calculates the close time of a candlestick based on
     * the time it was opened.
     * @param openTime 
     * @returns number
     */
    private calculateCandlestickCloseTime(openTime: number): number { 
        return moment(openTime).add(this.candlestickIntervalMinutes, "minutes").valueOf() - 1;
    }






    /**
     * Cleans the position candlesticks in case a position
     * is no longer active.
     * @returns cleanCandlesticks(): Promise<void>
     */
    private async cleanCandlesticks(): Promise<void> {
        // Clean the long position candlesticks if applies
        if (!this.long) {
            await this._model.cleanPositionHealthCandlesticks("LONG");
            this.longCandlesticks = { hp: undefined, dd: undefined };
        }

        // Clean the short position candlesticks if applies
        if (!this.short) {
            await this._model.cleanPositionHealthCandlesticks("SHORT");
            this.shortCandlesticks = { hp: undefined, dd: undefined };
        }
    }
}
